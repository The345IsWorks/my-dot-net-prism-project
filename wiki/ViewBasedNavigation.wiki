#summary One-sentence summary of this page.
#sidebar TableOfContents

= 8. View-Based Navigation =

In this module we are going to learn how to implement View-Based Navigation. In Prism 4 regions have been extended to provide view-based navigation services.

  * Basic Region Navigation
  * View and !ViewModel participation
  * Passing Parameters - between the view being navigated from to the view being navigated to.
  * Navigating to Existing Views
  * Confirming or Canceling Navigation
  * Navigation Journal - to implement custom Go Back or Go Forward type navigation

----
== Basic Region Navigation ==

Region navigation means that a view with in a region is replaced with another view.
  * view replaces view - this could be a new instance of a view or existing view
  * IVavigateAsyncRequestNavigate - you initiate navigation by calling the !RequestNavigate method that is defined by the INavigateAsync interface but despite its name it is not async.
    * !RequestNavigate
      * Region
{{{
IRegion region = ...;
region.RequestNavigate(New Uri("MyView", UriKind.Relative));
}}}
      * !RegionManager
{{{
IRegionManager regionManager = ...;
regionManager.RequestNavigate(RegionNames.ContentRegion, new Uri("MyView", UriKind.Relative));
}}}
  * Based on URI's - Views are identified by URI's by default this refers to the name of the view to be navigated to.
  * Type must register as Object - we also have to register our view with the container differently than you would expect.
    * Register Types as Object
      * Standard registration
{{{
Container.RegisterType<HomeView>("HomeView");

Container.RegisterType<IHomeView, HomeView>("Homeview");
}}}
      * Navigation registration
{{{
Container.RegisterType<object, HomeView>("HomeView");

Container.RegisterType(typeof(object>, typeof(HomeView), "HomeView");
}}}
  * View or !ViewModel first

Basic Region Navigation - cont.
  * Navigation Callback
{{{
private void Navigate(string navigatePath)
{
  RegionManager.RequestNavigate(Region.Names.ContentRegion, navigatePath, NavigateionCompleted);
}

private void NavigateionCompleted(NavigationResult result)
{
  ...
}
}}}

----
== Demo Basic Region Navigation ==

In this demo we have an application that we want to add View-Based Navigation to. The application has two modules ModuleA and ModuleB each module will have a button, this button will be used to navigate to the modules view and the module has a view which simply displays the name of the current view. Now lets look at the shell, there we have two regions, we have !StackPanel as our toolbar region and a !ContentControl as our content region where the views will be injected into


*ViewAButton*
{{{
<UserControl x:Class="ModuleA.ViewAButton"
	     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	     xmlns:views="clr-namespace:ModuleA"
	     xmlns:infCommands="clr-namespace:Demo.Infrastructure;assebly=Demo.Infrastructure">
  <Grid Margin="5">
    <Button>Navigate to View A</Button>
  </Grid>
</UserControl>
}}}

*ViewA*
{{{
<UserControl x:Class="ModuleA.ViewA"
	     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	     xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
	     xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
	     mc:Ignorable="d"
	     d:DesignHeight="300" d:DesignWidth="300">
  <Grid>
    <TextBlock Text="ViewA" FontSize="48" HorizontalAlignment="Center" VerticalAlignment="Center">ViewA</TextBlock>
  </Grid>
</UserControl>
}}}

*Shell*
{{{
<Window x:Class="Demo.Shell"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:prism="http://www.codeplex.com/prism"
	xmlns.inf="clr-namespace:Demo.Infrastructure;assembly=Demo.Infrastrcture"
	Title="Shell">
  <DockPanel LastChldFill="True">
    <StackPanel Orientation="Horizontal" DockPanel.Dock="Top" prism:RegionManager.RegionName="{x:Static inf:RegionNames.ToolbarRegion}" Margin="5" />
    <ContentControl prism:RegionManager.RegionName="{x:Static inf:RegionNames.ContentRegion}" Margin="5" />
  </DockPanel>
</Window>
}}}

Now lets create a compositCommand in our infrastructure project, create a class named !ApplicationCommands
{{{
public class ApplicationCommands
{
  public static CompositeCommand NavigateCommand = new CompositeCommand();
}
}}}

In this case we want the shell to be responsible for managing the navigation
{{{
public class ShellViewModel : viewModelBase, IShellViewModel
{
  private readonly IRegionManager _regionManager;

  public DelegateCommand<object> NavigateCommand { get; private set; }

  public ShellViewModel(IRegionManager regionManager)
  {
    _regionManager = regionManager;
    NavigateCommand = new DelegateCommand<object>(Navigate);
    ApplicationCommand.NavigateCommand.RegisterCommand(NavigateCommand);
  }

  private void Navigate(object navigatePath)
  {
    if(navigatePath != null)
      _regionManager.RequestNavigate(RegionNames.ContentRegion, navigatePath.ToString());
  }
}
}}}

Next we hook up our buttons to this command, so lets change the button properties in our !ViewAButton.xaml
{{{
<Button Command="{x:Static infCommands:ApplicationCommand.NavigateCommand}" CommandParameter="{x:Type views:ViewA}">Navigate to View A</Button>
}}}
And we do the same thing for ModuleB button.
We also have to change our ModuleAModule.cs !RegisterTypes() method
{{{
Container.RegisterType<object, ViewB>(typeof(ViewB).FullName);
}}}

To help ease the process of navigating types for navigation we provide an extension method in the Demo.Infrastructure project.
{{{
public static class UnityExtensions
{
  public static void RegisterTypeForNavigation<T>(this IUnityContainer container)
  {
    container.RegisterType(typeof(Object), typeof(T), typeof(T).FullName);
  }
}
}}} 

So we can change our !RegisterTypes method in ModuleAModule class to this
{{{
protected override void RegisterTypes()
{
  Container.RegisterTypeForNavigation<ViewA>();
}
}}}

Now lets implement to let us know when the navigation process is completed. To do that we go to our !ShellViewModel and change the Navigate method
{{{
private void Navigate(object navigatePath)
{
  if(navigatePath != null)
    _regionManager.RequestNavigate(RegionNames.ContentRegion, navigatePath.ToString(), NavigateComplete);
}

private void NavigateComplete(NavigationResult result)
{
  MesssageBox.Show(String.Format("Navigation to {0} complete.", result.Context.Uri));
}
}}}

----
== View and !ViewModel Participation ==

View based navigation involves replacing one view with another and often is required to know when the old view is being navigated away from and the new view is being navigated to. Prism provides a way for your view and or viewModel to participate in this process and thats by implementing the INavigationAware interface.
  * INavigationAware - lets look at the definition of this interface
{{{
public interface INavigateionAware
{
  bool IsNavigationTarget(NavigationContext navigationContext);
  void OnNavigatedFrom(NavigationContext navigationContext);
  void OnNavigatedTo(NavigationContext navigationContext);
}
}}}
We see that there are three methods
  * !IsNavigationTarget - which allows existing view or viewModel to determine if it can participate in the navigation request.
  * !OnNavigatedFrom - which is called on the current view before the navigation takes place.
  * !OnNavigatedTo - which is called after navigation is complete on the newly activated view

<img src="http://s17.postimg.org/ovez1gub3/inavigationaware.png" />

After the new view has been navigated to, the old view is deactivated with in the region.

  * IRegionMemberLifetime - if you want to remove the view form the region completely
{{{
public interface IRegionMemberLifetime
{
  bool KeepAlive { get; }
}
}}}
If you set the !KeepAlive property to false then the view is removed completely when the view is deactivated.