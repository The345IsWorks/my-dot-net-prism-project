#This page contains notes on the whole course

= Introduction to Prism =

This is a exercise in .NET Prism pattern library, where we follow the [http://pluralsight.com/training/courses/TableOfContents?courseName=prism-introduction&highlight=brian-lagunas_prism1-01-intro*1,3,4,7,0,2,8,5,6!brian-lagunas_prism1-02-bootstrapper-shell*0,9,1,2,6,3,4,5,7,8!brian-lagunas_prism1-03-regions*0,1,2,4,6,3,5!brian-lagunas_prism1-04-modules*0,1,4,10,11,2,3,5,6,7,8,9!brian-lagunas_prism1-05-views*0,1,5,6,8,11,2,7,9,3,10,4!brian-lagunas_prism1-6-communication*0,1,2,4,6,8,10,12,3,5,7,11,9!brian-lagunas_prism1-07-state-based-navigation*0,5,4,1,2,3!brian-lagunas_prism1-08-view-based-navigation*0,13,1,3,5,6,7,9,11,2,4,8,10,12#prism1-01-intro pluralsight tutorial] with with Brian Lagunas


== 1. Getting started with Prism ==

=== INTRODUCTION ===
Exercise in Prism pattern library
How to architect your projects so they will evolve and stand the test of time and don't break the second you change something. That is what Prism can give you.

  * What is Prism?
  * Benefits
  * Get Prism
  * How it works

<hr />
=== WHAT IS PRISM? ===
Framework for developing [http://en.wikipedia.org/wiki/Composite_application composite applications].
Take large applications and break it down to smaller more manageable pieces.
It is specific to WPF, Silverlight and Windows Phone 7.
Relies on design patterns to help promote [http://en.wikipedia.org/wiki/Loose_coupling loose coupling] and [http://en.wikipedia.org/wiki/Separation_of_concerns separation  of concern].<br />
some patterns are:
  * [http://en.wikipedia.org/wiki/Dependency_injection dependency injection pattern]
  * [http://en.wikipedia.org/wiki/Inversion_of_control Inversion of control pattern]
  * [http://en.wikipedia.org/wiki/Command_pattern Command pattern]
  * [http://en.wikipedia.org/wiki/Model_View_ViewModel Model View ViewModel MVVM pattern]
just to name a few.

<hr />
=== BENEFITS ===
  * *[http://en.wikipedia.org/wiki/Code_reuse REUSE]* - It was designed around architectural design patterns such as [http://en.wikipedia.org/wiki/Separation_of_concerns separation of concerns] and [http://en.wikipedia.org/wiki/Loose_coupling loose coupling] this allows Prism to provide you with many benefits. Most common benefit when using a framework is reuse, where you can build a component once and use it multiple times in a single application or cross applications and with Prism you take it a step further where you can build a component in WPF and use it in Silverlight so it is cross platforms.
  * *[http://en.wikipedia.org/wiki/Extensible_programming EXTENSIBLE]* - allows you to add new capabilityes and more easely intergrate them to your system
  * *FLEXIBLE* - can have components replaced with alternative implementations at runtime
  * *[http://en.wikipedia.org/wiki/Team_programming TEAM DEVELOPMENT]* - with larger projects broken down too smaller components it allows for multiple group members to work in the project at the same time
  * *[http://en.wikipedia.org/wiki/Software_quality QUALITY]* - Increases the quality of the code, because the application is broken down into smaller more manageable peaces, it allows common services and components to be fully tested.

<hr />
=== GET PRISM ===
You can get the Prism library from Microsoft patterns & practices in the following link

http://compositewpf.codeplex.com/

What you need:
  * Microsoft Windows 7, Windows Vista or Windows Server 2008
  * Microsoft .NET Framework 4.0 (installed with Visual Studio 2010)
  * Microsoft Visual Studio 2010 Express, Professional, Premium or Ultimate editions
  * Microsoft Silverlight 4 Tools for Visual Studio 2010
  * Optional but recommended
    * Microsoft Expression Blend 4
    * Windows Phone Developer Tools SDK

<hr />
=== DEMO INSTALLING PRISM ===
just go through the wizard and unpack to a preferred location
the binary's are located in the Bin folder and they are separated into they're associated platform Desktop, Phone, Silverlight, and you can reference them from there in your project.
You can also run the RegisterPrismBinaries.bin file in the root directory to register the binary's in Visual Studio so you don't have to browse for the bins. There are also great documentation that follows the install. There are also great examples and quickstarts that come with prism. Prism also ships with its source, the source code to prism library in the PrismLibrary folder.

<hr />
=== BUILDING BLOCKS ===
  * *Shell* - a template to define the structure of the UI, it contains Regions.
  * *Regions* - Specify certain areas of the Shell as elements in which you are going to inject a View at runtime.
  * *Modules* - A single major functional area at you application, ideally this module would not depend on other module to function properly. Modules will contain a number of Views.
  * *Views* - Just a simple UI that the user interacts with. In Prism they are constructed using the MVVM design pattern.
  * *Bootstrapper* - A class that initializes the Prism Application. Create and configure Module catalogs your container any region adapter mappings and where you create and initialize the Shell.

<hr />
=== APPLICATION DESIGN ===

<img src="http://s17.postimg.org/brbnpypjz/app.png" width="400px"></img>
<img src="http://s23.postimg.org/b910ma8ez/prism.png" width="400px" />

<hr />
=== DEMO PRISM WALKTROUGH ===

*Shell.xaml*
{{{
<Window x:Class="HelloWorld.Shell"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:cal="http://www.codeplex.com/prism"
	Title="Hello World" Height="300" Width="300">
	<ItemsControl Name="MainRegion" cal:RegionManager.RegionName="MainRegion" />
</Window>
}}}

*HelloWorldModule.cs*
{{{
using Microsoft.Practices.Prism.Modularity;
using Microsoft.Practices.Prism.Regions;

namespace HelloWorldModule
{
  public class HelloWorldModule : IModule
  {
    private readonly IRegionViewRegistry regionViewRegistry;
    
    public HelloWorldModule(IRegionViewRegistry registry)
    {
      this.regionViewRegistry = registry;
    }

    public Initialize()
    {
      regionViewRegistry.RegisterViewWithRegion("MainRegion", typeof(Views.HelloWorldView)); // #3 Register the HelloWorldView with the MainRegion, and that is the mechanism that injects the View to the MainRegion in the Shell.
    }
  }
}
}}}

*HelloWorldView.xaml*
{{{
<UserControl x:Class="HelloWorldModule.Views.helloWorldView"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
	<Grid>
	  <TextBlock Text="Hello World" Foreground="Green" HorizontalAlignment="Center" VerticalAlignment="Center" FontFamily="Calibri" FontSize="24" FontWeight="Bold"></TextBlock>
	</Grid>
</UserControl>
}}}

*Bootstrapeper.cs*
{{{
using System.Windows;
using Microsoft.Practices.Prism.Modularity;
using Microsoft.Practices.Unity;
using Microsoft.Practices.Prism.UnityExtensins;

namespace HelloWorld
{
  class Bootstrapper : UnityBootstrapper
  {
    protected override DependencyObject CreateShell()
    {
      return this.Container.Resolve<Shell>();
    }

    protected override void InitializeShell()
    {
      base.InitializeShell();
      App.Current.MainWindow = (Window)this.Shell;
      App.Current.MainWindow.Show();
    }

    protected override void ConfigureModuleCatalog()
    {
      base.ConfigureModuleCatalog();

      ModuleCatalog moduleCatalog = (ModuleCatalog)this.ModuleCatalog;
      moduleCatalog.addModule(typeof(HelloWorldModule.HelloWorldModule)); // #2 This is where we add our HelloWorld module to the module catalog
    }
  }
}
}}}

*App.xaml.cs*

{{{
using System.Windows;

namespace HelloWorld
{
  public partial class App : Application
  {
    protected override void OnStartup(StartupEventArgs e)
    {
      base.OnStartup(e);
      Bootstrapper bootstrapper = new Bootstrapper();
      bootstrapper.Run();  // #1 this is the first thing that happens in the Application
    }
  }
}
}}}

<hr />
== 2. Bootstrapper and the Shell ==

=== WHAT IS THE BOOTSTRAPPER? ===

  * Initializes application - The bootstrapper is a class that is responsible for initializing the application.
  * Core Services - the first thing that is initialized. (non application specific services that are from prism the library)
    * IModuleManager - Initialize and retrieve the applications modules.
    * IModuleCatalog - Registers the modules the application is going to load.
    * IModuleInitializer - Initializes the modules.
    * IRegionManager - The visual containers for the UI.
    * IEventAggregator - Create events that are loosely coupled between the publisher and the subscriber.
    * ILoggerFacade - Rapper for logging mechanism, to implement your own logging mechanism.
    * IServiceLocator - Gives access to the container.
  * Application specific services - Services that are specific to the application and common amongst all application modules.

<hr />
=== BOOTSTRAPPER PROCESS ===

<img src="http://s12.postimg.org/f5m45v5ml/bootstrapper_process.png" />

<hr />
=== Demo Organize your Solution ===
  * Create new blank solution. Name "PrismDemo"
  * Open the project directory and create two folders
    * Libs -  Holds all the libraries that are going to be used in the application
      * Create a folder Prism v4 for the Prism libraries and copy the Prism files that you need into that folder.
        * Microsoft.Practices.Prism.dll
        * Microsoft.Practices.Prism.Interactivity.dll
        * Microsoft.Practices.Prism.MefExtensions.dll
        * Microsoft.Practices.Prism.UnityExtensions.dll
        * Microsoft.Practices.ServiceLocation.dll
        * Microsoft.Practices.Unity.dll 
    * Src
      * Create Business folder - holds project that deal with the domain
      * Create Modules folder that contains all the Prism modules
  * Add a new WPF Application project to the solution  and put it in the Src folder. Name "Demo".
  * Add a new WPF User Control Library to the solution and put it in the Src folder to. This is referred to as the Infrastructure project and that is the code that is shared and common across the application and modules. Name "Demo.Infrastructure". Delete the user control. We use the WPF User Control Library because when we add to the project we see the object that we use in WPF projects instead of Windows.Forms objects that come with the class library. 
  * Add two solution folders to match the folder solution, helps to keep the solution organized when there are many projects in the solution.
    * Create Modules folder
    * Create Business folder

<hr />
=== Demo Create a Unity Bootstrapper ===

Add a reference to to the Prism library bins;
  * Microsoft.Practices.Prism.dll
  * Microsoft.Practices.Prism.UnityExtensions.dll
  * Microsoft.Practices.Unity.dll
Next add a class to the Demo project, this is going to be the bootstrapper class.
  * make it public
  * add a using Microsoft.Practices.Prism.UnityExtensions
  * let it inherit the UnityBootstrapper
  * implement the abstract members
  * delete the MainWindow from the Demo project
  * in App.Xaml remove the {{{ StartupUri="MainWindow.xaml" }}} line
  * in App.xaml.cs we  override the OnStartup method
{{{ 
protected override void Onstartup(StartupEventArgs e)
{
	base.OnStartup(e);
	Bootstrapper bootstrapper = new Bootstrapper();
	bootstrapper.Run();
}
}}}

<hr />
=== What is the Shell? ===
  * Main window/Page - Where the primary user interface content is contained
  * "Master Page" - Similar to Master Page in ASP.NET, used as a template to define the overall appearance for the application.
  * Contains Regions - Shell contains regions in which views will be injected to at runtime

<hr />
=== Demo Create a Unity shell ===

  * add Window (WPF) to the Demo project name it Shell
  * add {{{ <TextBlock Text="Hello World" /> }}} to the Shell
  * remove the height and width settings from the Shell
  * add {{{ using Microsoft.Practises.Unity }}} statement to the Bootstrapper
  * replace the code in the CreateShell method {{{ return Container.Resolve<Shell>(); }}}
    * {{{ Resolve<T> }}} comes from the Microsoft.Practises.Unity
  * override the InitializeShell method in the Bootstrapper
{{{
protected override void InitializeShell()
{
	base.InitializeShell();
	App.Current.MainWindow = (Window)Shell; // needs using System.Windows
	// the reason we have to cast to Window is because CreateShell returns DependecyObject and the MainWindow takes the type of Window

	App.Current.MainWindow.Show();
}
}}}

<hr />
== 3. Regions ==

=== Introduction ===
These are the discussion in this section.
  * What are Regions? - What are they and what role do they play in our application
  * RegionManager - how it manages the regions in our Prism application
  * RegionAdapter -  the relationship between it and RegionManager
  * Create a Custom Region -  how to create a custom region, these are needed for regions that Prism does not support

<hr />
=== What are Regions? ===
  * "Placeholder" for dynamic content that is going to be presented in the UI or in the Shell.Named location that you can define where a View will appear.

<img src="http://s16.postimg.org/z7wwjn9j9/region.png" width="400" /><br>
These regions define areas of the UI where we're gonna inject a view. Each region should be specifically named that describes the type of content that we are going to inject into that region

  * No knowledge of views - they have no knowledge of views
<img src="http://s12.postimg.org/4r2jlczel/region2.png" width="400" />
<br>We can redesign our Shell and it will have no impact on the region injection, no need to modify the infrastructure or module code.

  * Create in code or in XAML -  region is not a control, its apply to a control via the region name attach property on the region manager.

  * implements IRegion - Region implements the IRegion interface

<hr />
=== Region Manager ===
is responsible for managing the regions in the application.<br> It does it by:
  * Maintains collection of regions - creates new regions for controls
  * Provides a RegionName attached property - used to create regions by applying the attach property to the host control, can be done through XAML or code.
  * Maps RegionAdapter to controls - responsible for associating region with the host control. in order to expose a UI control as a region it must have a region adapter, and each region adapter adapts a specific type of UI control.<br> *Prism Region Adapters*
    * ContentControlRegionAdapter
    * ItemsControlRegionAdapter
    * SelectorRegionAdaptor
    * TabControlRegionAdapter (Silverlight only)
  * Provides a RegionContext attached property -  similar to dataContext in XAML, it allows you to propagate its data down the visual tree. Technik used to share data between a parent view and a child view that are hosted within a region.

<hr />
=== Demo Creating Regions ===

Create a new project in the Modules folder Name it ModuleA, in that module there are two Views.
  * ContentView.xaml
{{{
<UserControl x:Class="ModuleA.ContentView"
             xmlns="http://schemas.microsoft.com/winfx/2006/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http//schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.micosoft.com/expression/blend/2008"
             mc:Ignorable="d"
             d:DesignHeignt="300" d:DesingWidth="300">
  <Grid background="LightCoral">
    <TextBlock Text="Content" VerticalAlignment="Center" HorizontalAlignment="Center />
  </Grid>
</UserControl>
}}}
  * toolbarview.xaml
{{{
<UserControl x:Class="ModuleA.ToolbarView"
             xmlns="http://schemas.microsoft.com/winfx/2006/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http//schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.micosoft.com/expression/blend/2008"
             mc:Ignorable="d"
             d:DesignHeignt="300" d:DesingWidth="300">
  <Button Content="Toolbar Item" />
</UserControl>
}}}
  * open Shell.xaml and replace the grid with DockPanel and with in the DockPanel add a ContentControl because the items we are going to inject into the Views are single instance. Thats why we use ContentControl as our region host.
{{{
// Add a namespace to the Shell
xmlns:prism="http://www.codeplex.com/prism"
 
<DockPanel LastChildfill="True">
  <ContentControl DockPanel.Dock="Top" prism:RegionManager.RegionName="ToolbarRegion" />  // we user the prism RegionName to identify the content controls as regions.
  <ContentControl prism:RegionManager.RegionName="ContentRegion" />
</Dockpanel>
}}}
  * In the ModuleA project Create ModuleAModule.cs class and put the below code in it:
{{{
using Microsoft.Practices.Prism.Modularity;
using Microsoft.Practices.Unity;
using Microsoft.Practices.Prism.Regions,

namespace ModuleA
{
  public class ModuleAModule : IModule
  {
    IUnityContainer _container;
    IregionManager _regionManager;

    public ModuleAModule(IUnityContainer container, IRegionMaganer regionManager)
    {
      _container = container;
      _regionManager = regionManager;
    }

    public void Initialize()
    {
      _regionManager.RegisterViewWithRegion("ToolbarRegion", typeof(ToolbarView));
      _regionManager.RegisterViewWithRegion("ContentRegion", typeof(ContentView));
    }
  }
}
}}}
  * Now lets change this a little bit to get rid of the "magic string" like "ToolbarRegion" and "ContentRegion" and create constans instead
  * Add a class the the Demo.Infrastructure project, Name RegionNames.cs
{{{
namespace Demo.Infrastructure
{
  public class RegionNames
  {
    public static string ToolbarRegion = "ToolbarRegion";
    public static string ContentRegion = "ContentRegion";
  }
}
}}}
  * Open the Shell.xaml and add a namespace
{{{
xmlns:inf="Demo.Infrastructure;assembly=Demo.Infrastructure"
}}}
  * And change how we set the region name
{{{
<ContentControl DockPanel.Dock="Top" prism:RegionManager.RegionName="{x:Static inf:RegionNames.ToolbarRegion}" />
}}}
  * And do the same for ContentRegion
  * Open the ModuleAModule.cs and change the region names there to.
{{{
using Demo.Infrastructure;

_regionManager.RegisterViewWithRegion(RegionNames.ToolbarRegion, typeof(ToolbarView));
}}}
  * Now we can change the layout of the Shell without having to change any thing else.
{{{
DockPanel.Dock="Bottom"
}}}
  * Now we are going add multiple item in the ToolbarRegion so we need to change from ContentControl to ItemsControl
  * To simulate this go to ModuleAModule and change how we register the ToolbarRegion with the manager.
{{{
IRegion region = _regionManager.Regions[RegionNames.ToolbarRegion];
region.add(_container.Resolve<ToolbarView>());
region.add(_container.Resolve<ToolbarView>());
region.add(_container.Resolve<ToolbarView>());
region.add(_container.Resolve<ToolbarView>());
region.add(_container.Resolve<ToolbarView>());
}}}

<hr />
=== Custom Region ===

When you have a third party control or a custom control as your region host, but it has to support one of the region adapters provided by prism but if that is not the case then we can create our own custom region adapter.

how to create custom region:
  * Derive from {{{RegionAdapterBase<T>}}} - Create a class that derives from region adapter base
  * Implement CreateRegion method -  and return one of the three objects
    * SingleActiveRegion -  allows one active view, used for content controls
    * AllActiveRegion - keeps all the views in it active, deactivation of views are not allowed, used for items controls
    * Region - allows multiple active views, used for selector control
  * Implement Adapt method -  the code that adapt the control
  * Register your adapter

<hr />
=== Custom Region ===

When you have a third party control or a custom control as your region host, but it has to support one of the region adapters provided by prism but if that is not the case then we can create our own custom region adapter.

how to create custom region:
  * Derive from {{{RegionAdapterBase<T>}}} - Create a class that derives from region adapter base
  * Implement CreateRegion method -  and return one of the three objects
    * SingleActiveRegion -  allows one active view, used for content controls
    * AllActiveRegion - keeps all the views in it active, deactivation of views are not allowed, used for items controls
    * Region - allows multiple active views, used for selector control
  * Implement Adapt method -  the code that will adapt the control
  * Register your adapter - register the adapter with bootstrapper

<hr />
=== Demo Create a custom Region ===

  * Add a class to the Demo.Infrastructure project and name it StackPanelRegionAdapter
{{{
using Microsoft.Practices.Prism.Regions;
using System.Windows.Controls;

namespace Demo.Infrastructure
{
  public class StackPanelRegionAdapter : RegionAdapterBase<StackPanel>
  {
    public StackPanelRegionAdapter(IRegionBehaviorFactory regionFactory)
	: base(regionBehaviorFactory)
    {
      
    }
    protected override void Adapt(IRegion region, StackPanel regionTarget)
    {
      region.Views.CollectionChanged += (s, e) =>
	{
	  if(e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add)
	  {
	    foreach(FramworkElement element in e.NewItems)
	    {
	      regionTarget.Children.Add(element);
	    }
	  }
          // TODO handle remove
	};
    }

    protected override Iregion CreateRegion()
    {
      return new AllActiveRegion();
    }
  }
}
}}}

  * Open Bootstrapper and override method ConfigureRegionAdapterMappings
{{{
using Microsoft.Practices.Prism.Regions;
using Demo.Infrastructure;

protected override Microsoft.Practices.Prism.Regions.RegionAdapterMappings ConfigureRegionAdapterMappings()
{
  RegionAdapterMappings mappings = base.Configure.RegionAdapterMappings();
  mappings.RegisterMappings(typeof(StackPanel), Containter.Resolve<StackPanelRegionAdapter>());
  return mappings;
}
}}}
  * Change the content control in the Shell from DockPanel to StackPanel

Steps involved in creating custom region
  # change the control host to StackPanel
  # Create StackPanelRegionAdapter
  # Register the adapter in Bootstrapper

<hr />
== 4. Modules ==

=== Introduction ===

This section will explain how to take the views and logic out of a large application and break them down into a smaller peaces called Modules and use the in the Prism application.
  * What is a Module?
  * Registering Modules
  * Loading Modules
  * Initializing Modules

<hr />
=== What is a Module? ===

  * Building block of a Prism application, a package that bundles up all the functionality and resources for a portion of the overall application.

Current architecture that we want to change:
  *a Solution that has a Single Main Project with
    * all the views
    * all services
    *all business logic
    * and every single code that has to do with this application is in a single project
<img src="http://s17.postimg.org/brbnpypjz/app.png" width="400px"></img>

We want to identify the major functional areas of our application and start breaking them down into smaller more manageable peaces, and those peaces are called Modules<br>
<img src="http://s23.postimg.org/b910ma8ez/prism.png" width="400px" />

  * Class library/XAP - we have broken the project down into modules and the result is a class library that can be used in other applications.

  * Class that implements IModule - each module has a class that implements the IModule interface and that is what identifies it as a module to the Prism library, it has a single method in it called Initialize, which is responsible for initializing the module and integrating it into the Prism application. 

<hr />
=== Demo Creating a Module ===

  * Add a WPF User Control Library into the solutions module folder, call it ModuleA and save it to the module folder in our directory structure.
  * delete the UserControl
  * add a reference Microsoft.Practices.Prism.dll
  * add a class and name it ModuleAModule
  * it has to be public and implement the IModule and the Initialize method

<hr />
=== Registering Discovering Modules ===

Module Lifetime - first we start by:
  * Register Modules
  * Discover Modules

All the modules that need to be loaded at runtime are defined in the ModuleCatalog, it contains information about all the modules to be loaded, their location, order to be loaded and if a module is dependent on another module. 

There are some options on how to register the modules with the ModuleCatalog:
  * Code - the shell will require a reference to the module
  * XAML - Then the application does not require that reference to the module
  * Configuration File (WPF) - Then the application does not require that reference to the module
  * Disk (WPF) - Use a directory on a disk and the application discovers the modules at runtime and we don't need to specify them in a file

<hr />
=== Loading Modules ===

the next process in the module lifetime
  * ~~Register Modules~~ - done
  * ~~Discover Modules~~ - done
  * Load Modules - All of the assemblies that contain the modules need to be loaded into memory.
This may require the modules to be retrieved from disk
    * From disk (WPF) - local directory or remote directory (Shared directory on a network)
    * Downloaded from web (Silverlight)
    * Control when to load - Prism allows us to control when to load the modules:
      * When available - as soon as possible
      * On-demand - when the application needs them
      * download or download in background (Silverlight)

Guidelines for Loading Modules
  * Required to run? - is it required to run the application, then it needs to be downloaded and initialized when the application runs
  * Always used? - is it always used or almost always used then it can be downloaded in the background and initialized when it becomes available.
  * Rarely used? - download in the background and initialize on-demand

When we are designing our modules consider how we are breaking the application up, consider common usage scenarios or application startup times, that will help us how to configure our module for downloading and initialization

<hr />
=== Demo Register Load Modules in Code ===

Here we are going to override the ConfigureModuleCatalog method in the Bootstrapper, and we need to add a reference to the module and a using statement in the Bootstrapper.

{{{
protected override void ConfigureModuleCatalog()
{
  Type moduleAType = typeof(ModuleAModule);
  ModuleCatalog.AddModule(new ModuleInfo()
  {
    ModuleName = moduleAType.Name,
    ModuleType = moduleAtype.AssemblyQualifiedName,
    InitializationMode = InitializationMode.WhenAvailable
  });
}
}}}

<hr />
=== Demo Register Load Modules from Directory ===

To setup the Prism application to load the modules from a directory, we modify the Bootstrapper by overriding the CreateModuleCatalog method.


{{{
protected override void CreateModuleCatalog()
{
  return new DirectoryModuleCatalog() { ModulePath = @".\Modules" };
}
}}}

We need to make sure that we are pointing to a valid directory.
If we want to see it work then copy a module dll to that directory.
To define the ModuleName and Initialization method we use attributes.
{{{
[Module(ModuleName="ModuleA", OnDemand=true)]
public class ModuleAModule : IModule
}}}

By default the initialization method is going to be when available but we can change it to OnDemand in that Module attribute. If that module has some dependencies then we use this code.
{{{
[ModuleDependency("")]
public class ModuleAModule : IModule
}}}

<hr />
=== Demo Register Load Modules from XAML ===

Add a Resource Dictionary (WPF) to the shell project name it XamlCatalog. In the properties for the file set the "Build Action" to Resource. Add a namespace 
{{{
xmlns:Modularity="Microsoft.Practices.Prism.Modularity;assembly=Microsoft.Practices.Prism"
}}}

Replace the ResourceDictionary tags with Modularity:ModuleCatalog.
Next we add a new ModuleInfo declaration
{{{
<Modularity:ModuleInfo Ref="file://ModuleA.dll" ModuleName="ModuleA" ModuleType="ModuleA.ModuleAModule, ModuleA, Version=1.0.0.0" InitializationMode="WhenAvailable" />
}}}

The end result
{{{
<Modularity:ModuleCatalog xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:Modularity="Microsoft.Practices.Prism.Modularity;assembly=Microsoft.Practices.Prism">
  <Modularity:ModuleInfo Ref="file://ModuleA.dll" ModuleName="ModuleA" ModuleType="ModuleA.ModuleAModule, ModuleA, Version=1.0.0.0" InitializationMode="WhenAvailable" />
</Modularity:ModuleCatalog>
}}}

Next we open the Bootstrapper and override the CreateModuleCatalog method.
{{{
protected override IModuleCatalog CreateModuleCatalog()
{
  return Microsoft.Practices.Prism.Modularity.ModuleCatalog.CreateFromXaml(new Uri("/Demo;component/XamlCatalog.xaml", UriKind.Relative));
}
}}}

We need to copy the module to the root of the application for this to work. Would be a good idea to create a build action to copy the modules to the application root folder

<hr />
=== Demo Register Load Modules from App.config File ===

We start by overriding the CreateModuleCatalog method in the Bootstrapper.
{{{
protected override IModuleCatalog CreateModuleCatalog()
{
  return new ConfigurationModuleCatalog();
}
}}}

Add App.config file to the shell project. Add configSection tag to the App.config, create a new section and give it the name "modules" and the type "Microsoft.Practices.Prism.Modularity.ModulesConfigurationSection, Microsoft.Practices.Prism".
Now we can define the modules
{{{
<modules>
  <module assemblyFile="Modules/ModuleA.dll" moduleType="ModuleA.ModuleAModule, ModuleA, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" moduleName="ModuleA" startupLoaded="true" />
</modules>
}}}

end result:
{{{
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <configuration>
    <section name="modules" type="Microsoft.Practices.Prism.Modularity.ModulesConfigurationSection, Microsoft.Practices.Prism" />
  </configuration>
  <modules>
    <module assemblyFile="Modules/ModuleA.dll" moduleType="ModuleA.ModuleAModule, ModuleA, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" moduleName="ModuleA" startupLoaded="true" />
  </modules>
</configuration>
}}}

Open ModuleAModule and add a code to show MessageBox when the module initializes.
{{{
MessageBox.Show("ModuleA Loaded");
}}}

And lets create a post build event and go to ModuleA project properties, select the Build Events tab and put this command in the Post-build event command line: box.
{{{
xcopy "$(TargetDir)*.*" "$(SolutionDir)Src\Demo\bin\$(ConfigurationName)\Modules\" /Y
}}}

This command is going to copy the output of the ModuleA project into the Modules folder of our shell project.

<hr />
=== Initializing Modules ===

The last thing in the Module Lifetime is the Initialization.
  * ~~Register Modules~~
  * ~~Discover Modules~~
  * ~~Load Modules~~
  * Initialize Modules
<img src="http://s13.postimg.org/6l1fhqlif/module_lifetime.png" width="300px" />

*Initializing Modules*
  * IModule.Initialize()
  * Register types
  * Subscribe to services or events
  * Register shared services
  * Compose views into shell

When modules are being initialized, instances of the central module class are being created and the Initialize() method in them are being called via the IModule interface.
The Initialize method is where we write the code that is going to Register our types, we may subscribe to services or events, we can register shared services or we can compose our views into the shell. The initialize method is where we put all our code that does all the work to get our module ready for consumptions in our Prism application.

<hr />

== 5. Views ==
In this section we go over how Views work.
  * What is a View?
  * View Composition
  * View Discovery
  * View Injection

<hr />
=== What is a View? ===

  * Portion of the user interface -  smaller unit of the user interface which encapsulates a piece of functionality and decoupled from other parts of the User Interface.

Lets use Outlook as an example, when we first look at it you get the impression that you only have a single View to use and interact with the application. If we analyse it more closely we can identify sections of functionality that does not have any dependencies on other parts on the View:
  * Toolbar - probably its own view, has no dependencies on other parts of the application, its main function is to send messages of actions that need to be performed. Other parts of the application listen for specific messages and perform actions based on the message it receives
  * Navigation area
  * Email list Content area
  * Statusbar

<img src="http://s10.postimg.org/4o8igle9l/outlook_Views.png" width="600px" />

Even though the user sees one cohesive view it is composed of many views.

  * Can be made of multiple views (Composite view)
  * UserContol, Page, DataTemplate, etc...
  * Multiple instances - we can have tab control with number of taps in it showing the same view but they all show different data.
  * Patterns not required

<hr />
=== Demo Creating a View ===

Now we are going to create toolbarView and contentView. We begin by adding these views to the module "ModuleA".

  * Right click on the project and add user control and name it "ToolbarA", delete the grid from the XAML and add a button instead.
  * Add another user control and name it "ContentA" and add a TextBlock to the XAML grid.
  * We are not using any type of pattern to create these Views. Not in this section anyway.
  * Next we register our Views with our Container.
  * Open ModulAModule, in the Initialize method we need to register our views with our container.
  * Add a reference to Microsoft.Practices.Unity.dll
  * Add the namespace using Microsoft.Practices.unity
  * Add a private variable of IUnityContainer to the class.
  * Now create a public constructor that takes in IUnityContainer parameter and let the class variable of IUnityContainer take the value of the constructor variable.
  * Now we can register our views with the container in the Initialize method.

{{{
using Microsoft.Practices.Unity;

namespace ModuleA
{
  public class ModuleAModule : IModule
  {
    IUnityContainer _container;
    public ModuleAModule(IUnityContainer container)
    {
      _container = container;
    }

    public void Initialize()
    {
      _container.RegisterType<ToolbarA>();
      _container.RegisterType<ContentA>();
    }
  }
}
}}}

Whats happening here is when the module is created, Prism recocnizes that we are asking for IUnityContainer and provides us with one, once we have that container the Initialize mothod is going to be called and we start registering our Types with the container, once the types are registered with our container we can start using them with our module.

<hr />
=== Demo Creating a View (MVVM) ===

Now we are going to change the views in this module to use the MVVM design pattern.

  * Add a new Interface to the Demo.Infrastructure and name it IView.
  * Add another Interface to Demo.Infrastructure and name it IViewModel
  * Make sure they are both public
  * IView is going to have IViewModel instance property
  * IViewModel is going to have IView property, here the reference is to an interface not directly to the view
  * Normally we would create a base class but we are going to skip that step right now
  * Add a new interface to the ModuleA project and name it IContentAView
  * Add another interface to the ModuleA project and name it IContentViewViewModel
  * make them public
  * Add reference to the Demo.Infrastructure project and the namespace
  * Now let the IContentAView inherit the IView
  * Open the ContentA.xaml.cs code behind file and let it inherit the IContentAView and implement it
{{{
public Demo.Infrastructure.IViewModel ViewModel
{
  get
  {
    return (IContentAViewViewModel)DataContext;
  }
  set
  {
    DataContext = value;
  }
}
}}}

  * open IContentViewViewModel and let it inherit the IViewModel and implement it
  * Now lets create our ViewModel add a new class and name it ContentAViewViewModel, make sure its public and let it implement the IContentAViewViewModel
  * Now we create a constructor
{{{
public Demo.Infrastructure.IView View { get; set; }

public ContentAViewViewModel(IContentAView view)
{
  View = view;
  View.ViewModel = this;
}
}}}


So what's going to happen is when this ViewModel is resolved for our container it is going to see that we are asking for a view of Type IContentAView, when we get the view we are going to set the ViewModel to the current instance and when that happens the setter on the ViewModel property of the ContentA view will set the DataContext to that instance of the ViewModel, that is what binds the View and the ViewModel. But we have to register our types with our container.

Open ModuleAModule class and change the initialize method
{{{
_container.RegisterType<IContentAView, ContentA>();
_container.RegisterType<IContentAViewViewModel, ContentAViewViewModel>();
}}}

So whenever we ask for IContentAViewViewModel the container will resolve an instance of ContentAViewViewModel for us

<hr />
== 6. Commands ==
When building a Prism application we divide the application into individual, loosely coupled modules and sometimes it is necessary to communicate between those modules. To send data, user service or correspond to an action.
In this section we go over how to communicate between modules and still maintain loose coupling.
When we need to communicate between modules there are a couple of approaches that we can take:
  * Commanding - supports delegate commands, composite commands
  * Event Aggregation - 
  * Shared Services - 
  * Region Context - 

<hr />
=== Demo Creating a View (MVVM) - View First ===

In the previous demo we implemented the MVVM pattern in our Prism application using a ViewModel first approach, that is where the ViewModel is responsible for instantiating the View. Now lets take a look at more common View first approach that is when the View is responsible for instantiating the ViewModel.

  * Add a new interface to Demo.Infrastructure and name it IViewModel and make it public.
  * Add a new interface to Demo.Infrastructure and name it IView and make it public
  * IView should have IViewModel property
  * But the IView will not have IViewModel property.
  * Add a new interface to ModelA Project and name it IContentAViewViewModel make it public and implement IViewModel so we need a reference to Demo.Infrastructure and a using namespace.
  * Add a new class to ModelA and name it ContentAViewViewModel, should be public and implement IContentAViewViewModel
  * Add a constructor to the class 
  * Open the code behind for the ContentA view and implement the IView interface
{{{
public IViewModel ViewModel
{
  get
  {
    return (IViewModel)DataContext;
  }
  set
  {
    DataContext = value;
  }
}
}}}
  * Add a parameter of the type IContentAViewViewModel to the constructor and set the ViewModel to that parameter.

So what's going to happen is when we create an instance of this View, the view will create an instance of the IContentAViewViewModel and when that instance is created we are assigning that instance to the ViewModel property which is setting the DataContext to that instance. Thats where the binding between the ViewModel and the View is occurring

  * Lastly we need to register our types
{{{
_container.RegisterType<ToolbarA>();
_container.RegisterType<ContentA>();
_container.RegisterType<IContentAViewViewModel, ContentAViewViewModel>();
}}}

In the implementation we don't need to register our interface for the views.

<hr />