#summary One-sentence summary of this page.
#sidebar TableOfContents

= 8. View-Based Navigation =

In this module we are going to learn how to implement View-Based Navigation. In Prism 4 regions have been extended to provide view-based navigation services.

  * Basic Region Navigation
  * View and !ViewModel participation
  * Passing Parameters - between the view being navigated from to the view being navigated to.
  * Navigating to Existing Views
  * Confirming or Canceling Navigation
  * Navigation Journal - to implement custom Go Back or Go Forward type navigation

----
== Basic Region Navigation ==

Region navigation means that a view with in a region is replaced with another view.
  * view replaces view - this could be a new instance of a view or existing view
  * IVavigateAsyncRequestNavigate - you initiate navigation by calling the !RequestNavigate method that is defined by the INavigateAsync interface but despite its name it is not async.
    * !RequestNavigate
      * Region
{{{
IRegion region = ...;
region.RequestNavigate(New Uri("MyView", UriKind.Relative));
}}}
      * !RegionManager
{{{
IRegionManager regionManager = ...;
regionManager.RequestNavigate(RegionNames.ContentRegion, new Uri("MyView", UriKind.Relative));
}}}
  * Based on URI's - Views are identified by URI's by default this refers to the name of the view to be navigated to.
  * Type must register as Object - we also have to register our view with the container differently than you would expect.
    * Register Types as Object
      * Standard registration
{{{
Container.RegisterType<HomeView>("HomeView");

Container.RegisterType<IHomeView, HomeView>("Homeview");
}}}
      * Navigation registration
{{{
Container.RegisterType<object, HomeView>("HomeView");

Container.RegisterType(typeof(object>, typeof(HomeView), "HomeView");
}}}
  * View or !ViewModel first

Basic Region Navigation - cont.
  * Navigation Callback
{{{
private void Navigate(string navigatePath)
{
  RegionManager.RequestNavigate(Region.Names.ContentRegion, navigatePath, NavigateionCompleted);
}

private void NavigateionCompleted(NavigationResult result)
{
  ...
}
}}}

----
== Demo Basic Region Navigation ==

In this demo we have an application that we want to add View-Based Navigation to. The application has two modules ModuleA and ModuleB each module will have a button, this button will be used to navigate to the modules view and the module has a view which simply displays the name of the current view. Now lets look at the shell, there we have two regions, we have !StackPanel as our toolbar region and a !ContentControl as our content region where the views will be injected into


*ViewAButton*
{{{
<UserControl x:Class="ModuleA.ViewAButton"
	     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	     xmlns:views="clr-namespace:ModuleA"
	     xmlns:infCommands="clr-namespace:Demo.Infrastructure;assebly=Demo.Infrastructure">
  <Grid Margin="5">
    <Button>Navigate to View A</Button>
  </Grid>
</UserControl>
}}}

*ViewA*
{{{
<UserControl x:Class="ModuleA.ViewA"
	     xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	     xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	     xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
	     xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
	     mc:Ignorable="d"
	     d:DesignHeight="300" d:DesignWidth="300">
  <Grid>
    <TextBlock Text="ViewA" FontSize="48" HorizontalAlignment="Center" VerticalAlignment="Center">ViewA</TextBlock>
  </Grid>
</UserControl>
}}}

*Shell*
{{{
<Window x:Class="Demo.Shell"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:prism="http://www.codeplex.com/prism"
	xmlns.inf="clr-namespace:Demo.Infrastructure;assembly=Demo.Infrastrcture"
	Title="Shell">
  <DockPanel LastChldFill="True">
    <StackPanel Orientation="Horizontal" DockPanel.Dock="Top" prism:RegionManager.RegionName="{x:Static inf:RegionNames.ToolbarRegion}" Margin="5" />
    <ContentControl prism:RegionManager.RegionName="{x:Static inf:RegionNames.ContentRegion}" Margin="5" />
  </DockPanel>
</Window>
}}}

Now lets create a compositCommand in our infrastructure project, create a class named !ApplicationCommands
{{{
public class ApplicationCommands
{
  public static CompositeCommand NavigateCommand = new CompositeCommand();
}
}}}

In this case we want the shell to be responsible for managing the navigation
{{{
public class ShellViewModel : viewModelBase, IShellViewModel
{
  private readonly IRegionManager _regionManager;

  public DelegateCommand<object> NavigateCommand { get; private set; }

  public ShellViewModel(IRegionManager regionManager)
  {
    _regionManager = regionManager;
    NavigateCommand = new DelegateCommand<object>(Navigate);
    ApplicationCommand.NavigateCommand.RegisterCommand(NavigateCommand);
  }

  private void Navigate(object navigatePath)
  {
    if(navigatePath != null)
      _regionManager.RequestNavigate(RegionNames.ContentRegion, navigatePath.ToString());
  }
}
}}}

Next we hook up our buttons to this command, so lets change the button properties in our !ViewAButton.xaml
{{{
<Button Command="{x:Static infCommands:ApplicationCommand.NavigateCommand}" CommandParameter="{x:Type views:ViewA}">Navigate to View A</Button>
}}}
And we do the same thing for ModuleB button.
We also have to change our ModuleAModule.cs !RegisterTypes() method
{{{
Container.RegisterType<object, ViewB>(typeof(ViewB).FullName);
}}}

To help ease the process of navigating types for navigation we provide an extension method in the Demo.Infrastructure project.
{{{
public static class UnityExtensions
{
  public static void RegisterTypeForNavigation<T>(this IUnityContainer container)
  {
    container.RegisterType(typeof(Object), typeof(T), typeof(T).FullName);
  }
}
}}} 

So we can change our !RegisterTypes method in ModuleAModule class to this
{{{
protected override void RegisterTypes()
{
  Container.RegisterTypeForNavigation<ViewA>();
}
}}}

Now lets implement to let us know when the navigation process is completed. To do that we go to our !ShellViewModel and change the Navigate method
{{{
private void Navigate(object navigatePath)
{
  if(navigatePath != null)
    _regionManager.RequestNavigate(RegionNames.ContentRegion, navigatePath.ToString(), NavigateComplete);
}

private void NavigateComplete(NavigationResult result)
{
  MesssageBox.Show(String.Format("Navigation to {0} complete.", result.Context.Uri));
}
}}}

----
== View and !ViewModel Participation ==

View based navigation involves replacing one view with another and often is required to know when the old view is being navigated away from and the new view is being navigated to. Prism provides a way for your view and or viewModel to participate in this process and thats by implementing the INavigationAware interface.
  * INavigationAware - lets look at the definition of this interface
{{{
public interface INavigateionAware
{
  bool IsNavigationTarget(NavigationContext navigationContext);
  void OnNavigatedFrom(NavigationContext navigationContext);
  void OnNavigatedTo(NavigationContext navigationContext);
}
}}}
We see that there are three methods
  * !IsNavigationTarget - which allows existing view or viewModel to determine if it can participate in the navigation request.
  * !OnNavigatedFrom - which is called on the current view before the navigation takes place.
  * !OnNavigatedTo - which is called after navigation is complete on the newly activated view

<img src="http://s17.postimg.org/ovez1gub3/inavigationaware.png" width="400px" />

After the new view has been navigated to, the old view is deactivated with in the region.

  * IRegionMemberLifetime - if you want to remove the view form the region completely
{{{
public interface IRegionMemberLifetime
{
  bool KeepAlive { get; }
}
}}}
If you set the !KeepAlive property to false then the view is removed completely when the view is deactivated.

----
== Demo View and !ViewModel Participation ==

Now that we have implemented View-Based Navigation in our application lets take it a step further. This application has added a !ViewModule (!ViewAViewModel) to the views so each view has a viewModel and each viewModel is going to have a property called pageViews.
{{{
public class ViewAViewModel : ViewModelBase, IViewBBiewModel
{
  private int _pageViews;
  public int PageViews
  {
    get { return _pageViews; }
    set
    {
      _pageViews = value;
      OnPropertyChanged("PageViews");
    }
  }

  public ViewAViewModel()
  {

  }
}
}}}
What we want to do is when we navigate we want to update the count on how many times the page has been navigated to. So now we need our view and viewModels to participate in the navigate process.

We begin by implementing the INavigationAware interface to our viewModel
{{{
public class ViewAViewModel : ViewModelBase, IViewAViewModel, INavigationAware
{
  private int _pageViews;
  public int PageViews
  {
    get { return _pageViews; }
    set
    {
      _pageViews = value;
      OnPropertyChanged("PageViews");
    }
  }

  public ViewAViewModel()
  {

  }

  // INavigationAware implemnts these three methods
  public bool IsNavigationTarget(NavigationContext navigationContext)
  {
    return true;
  }

  public void OnNavigatedFrom(NavigationContext navigationContext)
  {

  }

  public void OnNavigatedTo(NavigationContext navigationContext)
  {
    PageViews++;
  }
}
}}}

Participation is not limited to viewModel we can also implement the INavigationAware on the view itself.
{{{
public partial class ViewA : UserControl, IView, INavigationAware
{
  public ViewA(IViewAViewModel viewModel)
  {
    InitializeComponent();
    ViewModel = viewModel;
  }

  public IViewModel ViewModel
  {
    get { return (IViewModel)DataContext; }
    set { DataContext = value; }
  }

  public bool IsNavigationTarget(NavigationContext navigationContext)
  {
    return true;
  }

  public void OnNavigatedFrom(NavigationContext navigationContext)
  {

  }

  public void OnNavigatedTo(NavigationContext navigationContext)
  {

  }
}
}}}
Now lets change the viewModel ViewBViewModel and implement the IRegionMemberLifetime
{{{
public class ViewBViewModel : ViewModelBase, IViewBViewModel, INavigationAware, IRegionMemberLifetime
{
  private int _pageViews;
  public int PageViews
  {
    get { return _pageViews; }
    set
    {
      _pageViews = value;
      OnPropertyChanged("PageViews");
    }
  }

  public ViewBViewModel()
  {

  }

  // INavigationAware implemnts these three methods
  public bool IsNavigationTarget(NavigationContext navigationContext)
  {
    return true;
  }

  public void OnNavigatedFrom(NavigationContext navigationContext)
  {

  }

  public void OnNavigatedTo(NavigationContext navigationContext)
  {
    PageViews++;
  }

  // IRegionMemberLifetime Property
  public bool KeepAlive
  {
    get { return false; }
  }
}
}}}
So each time we navigate from ViewB it is deactivated and deleted, so when we navigate to ViewB we create a new instance of the view.

----
== Passing Parameters ==

Sometimes it is necessary to pass parameters from the view that is being navigated from to the view that is being navigated to.
  * Append to navigation URI - this can be done by appending your parameters to the navigation URI that is passed to the request navigate method.
  * !UriQuery - Prism provides the !UriQuery class to help specify and retrieve parameters, for each parameter the !UriQuery object maintains a list of named value pairs. The name being the name of the parameter and the value being the value of the parameter.
  * Accessed from INavigationAware methods - you gain access to these parameters from with in the INavigationAware methods.
  * !NavigationContext
    * !NavigationService
    * URI
    * Parameters