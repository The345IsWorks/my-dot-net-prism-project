#This page contains notes on the whole course

= Introduction to Prism =

This is a exercise in .NET Prism pattern library, where we follow the [http://pluralsight.com/training/courses/TableOfContents?courseName=prism-introduction&highlight=brian-lagunas_prism1-01-intro*1,3,4,7,0,2,8,5,6!brian-lagunas_prism1-02-bootstrapper-shell*0,9,1,2,6,3,4,5,7,8!brian-lagunas_prism1-03-regions*0,1,2,4,6,3,5!brian-lagunas_prism1-04-modules*0,1,4,10,11,2,3,5,6,7,8,9!brian-lagunas_prism1-05-views*0,1,5,6,8,11,2,7,9,3,10,4!brian-lagunas_prism1-6-communication*0,1,2,4,6,8,10,12,3,5,7,11,9!brian-lagunas_prism1-07-state-based-navigation*0,5,4,1,2,3!brian-lagunas_prism1-08-view-based-navigation*0,13,1,3,5,6,7,9,11,2,4,8,10,12#prism1-01-intro pluralsight tutorial] with with Brian Lagunas


== 1. Getting started with Prism ==

=== INTRODUCTION ===
Exercise in Prism pattern library
How to architect your projects so they will evolve and stand the test off time and don't break the second you change something. That is what Prism can give you.

  * What is Prism?
  * Benefits
  * Get Prism
  * How it works

<hr />
=== WHAT IS PRISM? ===
Framework for developing [http://en.wikipedia.org/wiki/Composite_application composite applications].
Take large applications and break it down to smaller more manageable peaces.
It is specific to WPF, Silverlight and Windows Phone 7.
Relies on design patterns to help promote [http://en.wikipedia.org/wiki/Loose_coupling loose coupling] and [http://en.wikipedia.org/wiki/Separation_of_concerns separation  of concern].<br />
some patterns are:
  * [http://en.wikipedia.org/wiki/Dependency_injection dependency injection pattern]
  * [http://en.wikipedia.org/wiki/Inversion_of_control Inversion of control pattern]
  * [http://en.wikipedia.org/wiki/Command_pattern Command pattern]
  * [http://en.wikipedia.org/wiki/Model_View_ViewModel Model View ViewModel MVVM pattern]
just to name a few.

<hr />
=== BENEFITS ===
  * *[http://en.wikipedia.org/wiki/Code_reuse REUSE]* - It was designed around architectural design patterns such as [http://en.wikipedia.org/wiki/Separation_of_concerns separation of concerns] and [http://en.wikipedia.org/wiki/Loose_coupling loose coupling] this allows Prism to provide you with many benefits. Most common benefit when using a framework is reuse, where you can build a component once and use it multiple times in an single application or cross applications and with Prism you take it a step further where you can build a component in WPF and use it in Silverlight so it is cross platforms.
  * *[http://en.wikipedia.org/wiki/Extensible_programming EXTENSIBLE]* - allows you to add new capabilityes and more easely intergrate them to your system
  * *FLEXIBLE* - can have components replaced with alternetiv implementations at runntime
  * *[http://en.wikipedia.org/wiki/Team_programming TEAM DEVELOPMENT]* - with larger projects broken down too smaller components it allows for multiple group members to work in the project at the same time
  * *[http://en.wikipedia.org/wiki/Software_quality QUALITY]* - Increases the quality of the code, because the application is broken down into smaller more manageable peaces, it allows common services and components to be fully tested.

<hr />
=== GET PRISM ===
You can get the Prism library from Microsoft patterns & practices in the following link

http://compositewpf.codeplex.com/

What you need:
  * Microsoft Windows 7, Windows Vista or Windows Server 2008
  * Microsoft .NET Framework 4.0 (installed with Visual Studio 2010)
  * Microsoft Visual Studio 2010 Express, Professional, Premium or Ultimate editions
  * Microsoft Silverlight 4 Tools for Visual Studio 2010
  * Optional but recommended
    * Microsoft Expression Blend 4
    * Windows Phone Developer Tools SDK

<hr />
=== DEMO INSTALLING PRISM ===
just go through the wizard and unpack to a preferred location
the binary's are located in the Bin folder and they are separated into they'r associated platform Desktop, Phone, Silverlight, and you can reference them from there in your project.
You can also run the RegisterPrismBinaries.bin file in the root directory to register the binary's in Visual Studio so you don't have to brows for the bins. There are also great documentation that follows the install. There are also great examples and quickstarts that come with prism. Prism also ships with its source, the source code to prism library in the PrismLibrary folder.

<hr />
=== BUILDING BLOCKS ===
  * *Shell* - a template to define the structure of the UI, it contains Regions.
  * *Regions* - Specify certain areas of the Shell as elements in witch you are going to inject a View at runtime.
  * *Modules* - A single major functional area at you application, ideally this module would not depend on other module to function properly. Modules will contain a number of Views.
  * *Views* - Just a simple UI that the user interacts with. In Prism they are constructed using the MVVM desigh pattern.
  * *Bootstrapper* - A class that initializes the Prism Application. Create and configure Module catalogs your container any region adapter mappings and where you create and initialize the Shell.

<hr />
=== APPLICATION DESIGN ===

<img src="http://s17.postimg.org/brbnpypjz/app.png" width="400px"></img>
<img src="http://s23.postimg.org/b910ma8ez/prism.png" width="400px" />

<hr />
=== DEMO PRISM WALKTROUGH ===

*Shell.xaml*
{{{
<Window x:Class="HelloWorld.Shell"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:cal="http://www.codeplex.com/prism"
	Title="Hello World" Height="300" Width="300">
	<ItemsControl Name="MainRegion" cal:RegionManager.RegionName="MainRegion" />
</Window>
}}}

*HelloWorldModule.cs*
{{{
using Microsoft.Practices.Prism.Modularity;
using Microsoft.Practices.Prism.Regions;

namespace HelloWorldModule
{
  public class HelloWorldModule : IModule
  {
    private readonly IRegionViewRegistry regionViewRegistry;
    
    public HelloWorldModule(IRegionViewRegistry registry)
    {
      this.regionViewRegistry = registry;
    }

    public Initialize()
    {
      regionViewRegistry.RegisterViewWithRegion("MainRegion", typeof(Views.HelloWorldView)); // #3 Register the HelloWorldView with the MainRegion, and that is the mechanism that injects the View to the MainRegion in the Shell.
    }
  }
}
}}}

*HelloWorldView.xaml*
{{{
<UserControl x:Class="HelloWorldModule.Views.helloWorldView"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">
	<Grid>
	  <TextBlock Text="Hello World" Foreground="Green" HorizontalAlignment="Center" VerticalAlignment="Center" FontFamily="Calibri" FontSize="24" FontWeight="Bold"></TextBlock>
	</Grid>
</UserControl>
}}}

*Bootstrapeper.cs*
{{{
using System.Windows;
using Microsoft.Practices.Prism.Modularity;
using Microsoft.Practices.Unity;
using Microsoft.Practices.Prism.UnityExtensins;

namespace HelloWorld
{
  class Bootstrapper : UnityBootstrapper
  {
    protected override DependencyObject CreateShell()
    {
      return this.Container.Resolve<Shell>();
    }

    protected override void InitializeShell()
    {
      base.InitializeShell();
      App.Current.MainWindow = (Window)this.Shell;
      App.Current.MainWindow.Show();
    }

    protected override void ConfigureModuleCatalog()
    {
      base.ConfigureModuleCatalog();

      ModuleCatalog moduleCatalog = (ModuleCatalog)this.ModuleCatalog;
      moduleCatalog.addModule(typeof(HelloWorldModule.HelloWorldModule)); // #2 This is where we add our HelloWorld module to the module catalog
    }
  }
}
}}}

*App.xaml.cs*

{{{
using System.Windows;

namespace HelloWorld
{
  public partial class App : Application
  {
    protected override void OnStartup(StartupEventArgs e)
    {
      base.OnStartup(e);
      Bootstrapper bootstrapper = new Bootstrapper();
      bootstrapper.Run();  // #1 this is the first thing that happens in the Application
    }
  }
}
}}}

<hr />
== 2. Bootstrapper and the Shell ==

=== WHAT IS THE BOOTSTRAPPER? ===

  * Initializes application - The bootstrapper is a class that is responsible for initializing the application.
  * Core Services - the first thing that is initialized. (none application specific services that are from prism the library)
    * IModuleManager - Initialize and retrieve the applications modules.
    * IModuleCatalog - Registers the modules the application is going to load.
    * IModuleInitializer - Initializes the modules.
    * IRegionManager - The visual containers for the UI.
    * IEventAggregator - Create events that are loosely coupled between the publisher and the subscriber.
    * ILoggerFacade - Rapper for logging mechanism, to implement your own logging mechanism.
    * IServiceLocator - Gives access to the container.
  * Application specific services - Services that are specific to the application and common amongst all application modules.

<hr />
=== BOOTSTRAPPER PROCESS ===

<img src="http://s12.postimg.org/f5m45v5ml/bootstrapper_process.png" />

<hr />
=== Demo Organize your Solution ===
  * Create new blank solution. Name "PrismDemo"
  * Open the project directory and create two folders
    * Libs -  Holds all the librarys that are going to be used in the application
      * Create a folder Prism v4 for the Prism librarys and copy the Prism files that you need into that folder.
        * Microsoft.Practices.Prism.dll
        * Microsoft.Practices.Prism.Interactivity.dll
        * Microsoft.Practices.Prism.MefExtensions.dll
        * Microsoft.Practices.Prism.UnityExtensions.dll
        * Microsoft.Practices.ServiceLocation.dll
        * Microsoft.Practices.Unity.dll 
    * Src
      * Create Business folder - holds project that deal with the domain
      * Create Modules folder that contains all the Prism modules
  * Add a new WPF Application project to the solution  and put it in the Src folder. Name "Demo".
  * Add a new WPF User Control Library to the solution and put it in the Src folder to. This is referred to as the Infrastructure project and that is the code that is shared and common across the application and modules. Name "Demo.Infrastructure". Delete the user control. We use the WPF User Control Library because when we add to the project we see the object that we use in WPF projects instead of Windows.Forms objects that come with the class library. 
  * Add two solution folders to match the folder solution, helps to keep the solution organized when there are many projects in the solution.
    * Create Modules folder
    * Create Business folder

<hr />
=== Demo Create a Unity Bootstrapper ===

Add a reference to to the Prism library bins;
  * Microsoft.Practices.Prism.dll
  * Microsoft.Practices.Prism.UnityExtensions.dll
  * Microsoft.Practices.Unity.dll
Next add a class to the Demo project, this is going to be the bootstrapper class.
  * make it public
  * add a using Microsoft.Practices.Prism.UnityExtensions
  * let it inherit the UnityBootstrapper
  * implement the abstract members
  * delete the MainWindow from the Demo project
  * in App.Xaml remove the {{{ StartupUri="MainWindow.xaml" }}} line
  * in App.xaml.cs we  override the OnStartup method
{{{ 
protected override void Onstartup(StartupEventArgs e)
{
	base.OnStartup(e);
	Bootstrapper bootstrapper = new Bootstrapper();
	bootstrapper.Run();
}
}}}

<hr />
=== What is the Shell? ===
  * Main window/Page - Where the primary user interface content is contained
  * "Master Page" - Similar to Master Page in ASP.NET, used as a template to define the overall appearance for the application.
  * Contains Regions - Shell contains regions in which views will be injected to at runtime

<hr />
=== Demo Create a Unity shell ===

  * add Window (WPF) to the Demo project name it Shell
  * add {{{ <TextBlock Text="Hello World" /> }}} to the Shell
  * remove the height and width settings from the Shell
  * add {{{ using Microsoft.Practises.Unity }}} statement to the Bootstrapper
  * replace the code in the CreateShell method {{{ return Container.Resolve<Shell>(); }}}
    * {{{ Resolve<T> }}} comes from the Microsoft.Practises.Unity
  * override the InitializeShell method in the Bootstrapper
{{{
protected override void InitializeShell()
{
	base.InitializeShell();
	App.Current.MainWindow = (Window)Shell; // needs using System.Windows
	// the reason we have to cast to Window is because CreateShell returns DependecyObject and the MainWindow takes the type of Window

	App.Current.MainWindow.Show();
}
}}}

<hr />
== 3. Regions ==

=== Introduction ===
These are the discussion in this section.
  * What are Regions? - What are they and what role do they play in our application
  * RegionManager - how it manages the regions in our Prism application
  * RegionAdapter -  the relationship between it and RegionManager
  * Create a Custom Region -  how to create a custom region, these are needed for regions that Prism does not support

<hr />
=== What are Regions? ===
  * "Placeholder" for dynamic content that is going to be presented in the UI or in the Shell.Named location that you can define where a View will appear.

<img src="http://s16.postimg.org/z7wwjn9j9/region.png" width="400" /><br>
These regions define areas of the UI where we're gonna inject a view. Each region should be specifically named that describes the type of content that we are going to inject into that region

  * No knowledge of views - they have no knowledge of views
<img src="http://s12.postimg.org/4r2jlczel/region2.png" width="400" />
<br>We can redesign our Shell and it will have no impact on the region injection, no need to modify the infrastructure or module code.

  * Create in code or in XAML -  region is not a control, its apply to a control via the region name attach property on the region manager.

  * implements IRegion - Region implements the IRegion interface

<hr />
=== Region Manager ===
is responsible for managing the regions in the application.<br> It does it by:
  * Maintains collection of regions - creates new regions for controls
  * Provides a RegionName attached property - used to create regions by applying the attach property to the host control, can be done through XAML or code.
  * Maps RegionAdapter to controls - responsible for associating region with the host control. in order to expose a UI control as a region it must have a region adapter, and each region adapter adapts a specific type of UI control.<br> *Prism Region Adapters*
    * ContentControlRegionAdapter
    * ItemsControlRegionAdapter
    * SelectorRegionAdaptor
    * TabControlRegionAdapter (Silverlight only)
  * Provides a RegionContext attached property -  similar to dataContext in XAML, it allows you to propagate its data down the visual tree. Technik used to share data between a parent view and a child view that are hosted with in a region.

<hr />